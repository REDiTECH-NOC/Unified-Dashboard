generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  MANAGER
  USER
  CLIENT
}

enum AuthMethod {
  ENTRA
  LOCAL
}

enum MonitorType {
  HTTP
  TCP
  PING
  DNS
  REDIS
  MYSQL
  POSTGRESQL
  SQLSERVER
  MONGODB
  DOCKER
}

enum MonitorStatus {
  UP
  DOWN
  PENDING
  UNKNOWN
}

enum AuditCategory {
  AUTH
  USER
  SECURITY
  INTEGRATION
  NOTIFICATION
  SYSTEM
  API
  DATA
}

model User {
  id            String     @id @default(cuid())
  email         String     @unique
  name          String?
  avatar        String?
  entraId       String?    @unique
  role          Role       @default(USER)
  authMethod    AuthMethod @default(ENTRA)

  // Local auth fields (glass-break admin, future local users/clients)
  passwordHash  String?
  totpSecret    String?
  totpEnabled   Boolean    @default(false)
  mustSetupTotp Boolean    @default(false)

  // Future: invite flow for local users / clients
  inviteToken   String?    @unique
  inviteExpiry  DateTime?

  lastLoginAt   DateTime?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  auditEvents         AuditEvent[]
  preferences         UserPreference[]
  featureFlags        UserFeatureFlag[]
  permissions         UserPermission[]
  permissionRoles     UserPermissionRole[]
  integrationMappings UserIntegrationMapping[]
  quickLinkAssignments QuickLinkAssignment[]

  @@index([role])
  @@index([authMethod])
}

model AuditEvent {
  id        String        @id @default(cuid())
  action    String
  category  AuditCategory @default(SYSTEM)
  actorId   String?
  actor     User?         @relation(fields: [actorId], references: [id])
  resource  String?
  detail    Json?
  ip        String?
  userAgent String?
  outcome   String        @default("success")
  createdAt DateTime      @default(now())

  @@index([action])
  @@index([category])
  @@index([actorId])
  @@index([createdAt])
  @@index([resource])
  @@index([outcome])
  @@index([category, createdAt])
  @@index([actorId, createdAt])
}

model AuditRetentionConfig {
  id                 String    @id @default(cuid())
  retentionDays      Int       @default(2555) // 7 years
  autoCleanupEnabled Boolean   @default(false)
  cleanupFrequency   String    @default("monthly") // daily | weekly | monthly
  lastCleanupAt      DateTime?
  lastCleanupCount   Int       @default(0)
  updatedBy          String?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
}

model UserPreference {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  key       String
  value     Json
  updatedAt DateTime @updatedAt

  @@unique([userId, key])
}

model UserFeatureFlag {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  flag      String
  enabled   Boolean  @default(false)
  value     Json?
  updatedBy String?
  updatedAt DateTime @updatedAt

  @@unique([userId, flag])
}

model UserPermission {
  id         String   @id @default(cuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  permission String   // e.g. "audit.view", "users.manage", "kb.write"
  granted    Boolean  @default(true) // true = explicitly granted, false = explicitly revoked
  grantedBy  String?  // userId of admin who set this
  grantedAt  DateTime @default(now())

  @@unique([userId, permission])
  @@index([userId])
}

// Named permission groups that admins create and assign to users
// e.g. "Senior Tech" grants ai.kb.write + audit.view + reports.view
// Users can have multiple roles — most permissive wins
model PermissionRole {
  id          String   @id @default(cuid())
  name        String   @unique  // e.g. "Senior Tech", "Help Desk", "Security Analyst"
  description String?
  permissions String[] // array of permission keys: ["ai.kb.write", "audit.view"]
  createdBy   String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  users UserPermissionRole[]
}

// Join table: which users have which permission roles
model UserPermissionRole {
  id               String         @id @default(cuid())
  userId           String
  user             User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  permissionRoleId String
  permissionRole   PermissionRole @relation(fields: [permissionRoleId], references: [id], onDelete: Cascade)
  assignedBy       String?
  assignedAt       DateTime       @default(now())

  @@unique([userId, permissionRoleId])
  @@index([userId])
}

model IntegrationConfig {
  id              String    @id @default(cuid())
  toolId          String    @unique
  displayName     String
  category        String
  credentialRef   String?
  status          String    @default("unconfigured")
  lastHealthCheck DateTime?
  lastSync        DateTime?
  config          Json?
  updatedBy       String?
  updatedAt       DateTime  @updatedAt
}

model NotificationConfig {
  id              String   @id @default(cuid())
  type            String   @unique  // e.g. "alert_critical", "report_daily"
  displayName     String
  description     String?
  emailEnabled    Boolean  @default(false)
  emailSender     String?  // e.g. "alerts@cloudjohnson.com"
  emailRecipients String[] // array of email addresses
  teamsEnabled    Boolean  @default(false)
  teamsWebhookUrl String?
  smsEnabled      Boolean  @default(false)
  smsRecipients   String[] // array of phone numbers
  updatedBy       String?
  updatedAt       DateTime @updatedAt
}

// ─── In-App Notifications ──────────────────────────────────────

model InAppNotification {
  id         String   @id @default(cuid())
  userId     String
  type       String   // "ticket_assigned", "ticket_reply", "ticket_status_changed", "ticket_created"
  title      String
  body       String?
  read       Boolean  @default(false)
  linkUrl    String?
  sourceType String?  // "connectwise_ticket"
  sourceId   String?
  metadata   Json?
  expiresAt  DateTime?
  createdAt  DateTime @default(now())

  @@index([userId, read, createdAt(sort: Desc)])
  @@index([userId, createdAt(sort: Desc)])
  @@index([expiresAt])
}

// ─── Notification Delivery Channels (admin-managed) ─────────────

model NotificationChannel {
  id        String   @id @default(cuid())
  type      String   // "push" | "email" | "teams" | "sms"
  name      String   // "Browser Push", "Email", "NOC Alerts Channel"
  config    Json     @default("{}")
  isBuiltIn Boolean  @default(false) // push + email are built-in, can't be deleted
  enabled   Boolean  @default(true)
  createdBy String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([type, name])
}

// ─── User Notification Preferences (per-source, per-user) ──────

model UserNotificationPref {
  id         String   @id @default(cuid())
  userId     String
  source     String   // "sentinelone", "blackpoint", "ninjaone", "uptime", "cove"
  enabled    Boolean  @default(true)
  severities String[] // multi-select: ["critical", "high"]
  channels   String[] // delivery channels: ["push", "email", "teams:<channel-id>"]
  updatedAt  DateTime @updatedAt

  @@unique([userId, source])
  @@index([userId])
}

// ─── Uptime Monitoring ──────────────────────────────────────────

model Monitor {
  id              String        @id @default(cuid())
  name            String
  type            MonitorType
  active          Boolean       @default(true)

  // Organization assignment (optional — link to a client company)
  companyId       String?
  company         Company?      @relation(fields: [companyId], references: [id], onDelete: SetNull)

  // Scheduling
  intervalSeconds Int           @default(60)
  retrySeconds    Int           @default(60)
  maxRetries      Int           @default(3)
  timeoutMs       Int           @default(10000)

  // Current state (denormalized for fast list queries)
  status          MonitorStatus @default(PENDING)
  lastCheckedAt   DateTime?
  lastStatusChange DateTime?

  // Per-type config (JSONB — discriminated by type)
  config          Json          @default("{}")

  description     String?
  sslExpiryDays   Int           @default(30)

  createdBy       String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  heartbeats      Heartbeat[]
  tags            MonitorTagAssignment[]

  @@index([active])
  @@index([status])
  @@index([type])
  @@index([companyId])
}

model Heartbeat {
  id          String        @id @default(cuid())
  monitorId   String
  monitor     Monitor       @relation(fields: [monitorId], references: [id], onDelete: Cascade)
  status      MonitorStatus
  latencyMs   Int?
  message     String?

  // SSL/TLS info (populated on HTTPS checks)
  tlsInfo     Json?         // { issuer, subject, validFrom, validTo, daysUntilExpiry, fingerprint }

  // DNS result
  dnsResult   Json?         // { resolvedAddresses: string[], recordType: string }

  timestamp   DateTime      @default(now())

  @@index([monitorId, timestamp(sort: Desc)])
  @@index([timestamp])
  @@index([monitorId, status])
}

model MonitorTag {
  id        String   @id @default(cuid())
  name      String   @unique
  color     String   @default("#ef4444") // hex color for badge display
  createdBy String?
  createdAt DateTime @default(now())

  monitors  MonitorTagAssignment[]
}

model MonitorTagAssignment {
  id        String     @id @default(cuid())
  monitorId String
  monitor   Monitor    @relation(fields: [monitorId], references: [id], onDelete: Cascade)
  tagId     String
  tag       MonitorTag @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([monitorId, tagId])
  @@index([monitorId])
  @@index([tagId])
}

// ─── Company Management ─────────────────────────────────────────

// Local company record — PSA (ConnectWise) is the source of truth.
// All other tools map to these records via CompanyIntegrationMapping.
model Company {
  id             String    @id @default(cuid())
  name           String
  psaSourceId    String    @unique // ConnectWise company ID — authoritative link
  identifier     String?           // CW short code (e.g., "JBDAW")
  status         String    @default("Active")
  type           String?           // CW company type name (e.g. "Client", "Prospect")
  phone          String?
  website        String?
  addressLine1   String?
  addressLine2   String?
  city           String?
  state          String?
  zip            String?
  country        String?
  lastSyncedAt   DateTime?
  syncEnabled    Boolean   @default(true)
  syncSource     String    @default("manual") // "auto" | "manual"
  unmatchedSince DateTime?                    // when auto-sync detected no longer matches (null = matches)

  // ── In-App Custom Fields (admin-editable, NOT synced from CW) ──
  afterHoursAlertProcedure String?  // Free text: what to do for after-hours alerts
  notes                    String?  // General admin notes about this company

  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  integrationMappings      CompanyIntegrationMapping[]
  threecxInstances         ThreecxInstance[]
  monitors                 Monitor[]
  contacts                 CompanyContact[]
  sites                    CompanySite[]
  configurations           CompanyConfiguration[]
  agreements               CompanyAgreement[]
  reconciliationSnapshots  ReconciliationSnapshot[]
  billingAssignments       CompanyBillingAssignment[]
  billingIgnoredProducts   BillingIgnoredProduct[]

  @@index([name])
  @@index([status])
  @@index([syncSource])
}

// Contacts synced from ConnectWise — needed for 3CX caller intelligence, ticket creation
model CompanyContact {
  id                 String    @id @default(cuid())
  companyId          String
  company            Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  psaSourceId        String    @unique // CW contact ID
  firstName          String
  lastName           String
  title              String?
  email              String?
  phone              String?
  mobilePhone        String?
  defaultFlag        Boolean   @default(false)
  inactiveFlag       Boolean   @default(false)
  communicationItems Json?     // full CW communicationItems array for extended lookups
  lastSyncedAt       DateTime?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  @@index([companyId])
  @@index([email])
  @@index([phone])
  @@index([mobilePhone])
}

// Sites/locations synced from ConnectWise — company office addresses
model CompanySite {
  id           String    @id @default(cuid())
  companyId    String
  company      Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  psaSourceId  String    @unique // CW site ID
  name         String
  addressLine1 String?
  city         String?
  state        String?
  zip          String?
  country      String?
  phone        String?
  primaryFlag  Boolean   @default(false)
  inactiveFlag Boolean   @default(false)
  lastSyncedAt DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([companyId])
}

// Device/asset configurations synced from ConnectWise — needed for contract reconciliation
model CompanyConfiguration {
  id           String    @id @default(cuid())
  companyId    String
  company      Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  psaSourceId  String    @unique // CW configuration ID
  name         String
  type         String?
  status       String?
  serialNumber String?
  modelNumber  String?
  osType       String?
  osInfo       String?
  ipAddress    String?
  macAddress   String?
  lastSyncedAt DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([companyId])
}

// Agreements/contracts synced from ConnectWise — needed for billing reconciliation
model CompanyAgreement {
  id               String    @id @default(cuid())
  companyId        String
  company          Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  psaSourceId      String    @unique // CW agreement ID
  name             String
  type             String?
  startDate        DateTime?
  endDate          DateTime?
  cancelledFlag    Boolean   @default(false)
  noEndingDateFlag Boolean   @default(false)
  billAmount       Float?
  billCycle        String?
  lastSyncedAt     DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  additions AgreementAddition[]

  @@index([companyId])
}

// Line items within a CW agreement — each represents a billed product/service.
// Synced from ConnectWise GET /finance/agreements/{id}/additions
model AgreementAddition {
  id              String           @id @default(cuid())
  agreementId     String
  agreement       CompanyAgreement @relation(fields: [agreementId], references: [id], onDelete: Cascade)
  psaSourceId     String           @unique // CW addition ID
  productId       String?          // CW product catalog reference ID
  productName     String           // e.g., "SentinelOne Complete - Workstation"
  description     String?
  quantity        Float            @default(0) // Billed qty
  unitPrice       Float?
  unitCost        Float?
  effectiveDate   DateTime?
  endDate         DateTime?
  cancelledFlag   Boolean          @default(false)
  billCustomer    String?          // "Billable", "DoNotBill", "NoCharge"
  taxableFlag     Boolean          @default(false)
  lastSyncedAt    DateTime?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  @@index([agreementId])
  @@index([productName])
}

// All known vendor products — auto-discovered from APIs or manually created by admin.
// Replaces hardcoded vendor product lists. Each can be mapped to PSA billing items.
model BillingVendorProduct {
  id               String   @id @default(cuid())
  vendorToolId     String   // "sentinelone", "ninjaone", "cove", etc.
  productKey       String   // "complete", "control", "workstations", "servers", etc.
  productName      String   // "SentinelOne Complete", "NinjaOne Workstations"
  unit             String   @default("devices")
  isAutoDiscovered Boolean  @default(false) // true = pulled from vendor API, false = admin-created
  isActive         Boolean  @default(true)
  createdBy        String?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  assignments CompanyBillingAssignment[]

  @@unique([vendorToolId, productKey])
  @@index([vendorToolId])
}

// Links companies to vendor products — for billing reconciliation.
// Auto-discovered: populated during reconciliation (e.g., S1 site SKU → assignment).
// Manual: admin assigns products to companies in the UI.
model CompanyBillingAssignment {
  id               String   @id @default(cuid())
  companyId        String
  vendorProductId  String
  isAutoDiscovered Boolean  @default(false)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  company        Company              @relation(fields: [companyId], references: [id], onDelete: Cascade)
  vendorProduct  BillingVendorProduct @relation(fields: [vendorProductId], references: [id], onDelete: Cascade)

  @@unique([companyId, vendorProductId])
  @@index([companyId])
  @@index([vendorProductId])
}

// Per-company ignored vendor products — user chose to skip mapping these.
model BillingIgnoredProduct {
  id           String   @id @default(cuid())
  companyId    String
  vendorToolId String
  productKey   String
  createdAt    DateTime @default(now())

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([companyId, vendorToolId, productKey])
  @@index([companyId])
}

// Maps a vendor integration product/service to a PSA product name.
// E.g., SentinelOne "Complete" agents → CW "SentinelOne Complete - Workstation"
model BillingProductMapping {
  id                String   @id @default(cuid())
  vendorToolId      String   // "ninjaone", "sentinelone", "cove", etc.
  vendorProductKey  String   // Vendor-specific product identifier or category
  vendorProductName String   // Display name (e.g., "Complete - Workstation")
  psaProductName    String?  // CW product name pattern to match additions
  countMethod       String   @default("per_device") // "per_device", "per_user", "per_license", "per_mailbox"
  unitLabel         String   @default("devices")    // "devices", "agents", "users", "licenses", "mailboxes"
  isActive          Boolean  @default(true)
  createdBy         String?
  notes             String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([vendorToolId, vendorProductKey, psaProductName])
  @@index([vendorToolId])
  @@index([psaProductName])
}

// Point-in-time reconciliation run for a company.
// Captures vendor counts vs PSA billing for audit and history.
model ReconciliationSnapshot {
  id          String   @id @default(cuid())
  companyId   String
  company     Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  snapshotAt  DateTime @default(now())
  triggeredBy String?  // userId or "system" for scheduled
  status      String   @default("completed") // "in_progress", "completed", "failed"
  summary     Json?    // { totalDiscrepancies, totalRevenueImpact, matchedCount, ... }
  createdAt   DateTime @default(now())

  items ReconciliationItem[]

  @@index([companyId])
  @@index([snapshotAt])
  @@index([companyId, snapshotAt(sort: Desc)])
}

// Individual line-item comparison within a reconciliation snapshot.
model ReconciliationItem {
  id                String                 @id @default(cuid())
  snapshotId        String
  snapshot          ReconciliationSnapshot @relation(fields: [snapshotId], references: [id], onDelete: Cascade)
  companyId         String
  agreementId       String?  // local CompanyAgreement ID
  agreementName     String?
  additionPsaId     String?  // CW addition psaSourceId (for write-back)
  agreementPsaId    String?  // CW agreement psaSourceId (for write-back)
  productName       String   // PSA product name
  vendorToolId      String   // Source tool (ninjaone, sentinelone, cove)
  vendorProductKey  String?
  vendorProductName String?
  psaQty            Float    // What CW says is billed
  vendorQty         Float    // What the vendor reports
  discrepancy       Float    // vendorQty - psaQty (positive = underbilling)
  unitPrice         Float?   // Price per unit from CW addition
  revenueImpact     Float?   // discrepancy * unitPrice
  status            String   @default("pending") // "pending", "approved", "dismissed", "adjusted"
  resolvedBy        String?  // userId
  resolvedAt        DateTime?
  resolvedNote      String?
  createdAt         DateTime @default(now())

  @@index([snapshotId])
  @@index([companyId])
  @@index([status])
  @@index([vendorToolId])
}

// Configuration for recurring billing sync schedule
model BillingSyncConfig {
  id            String    @id @default(cuid())
  enabled       Boolean   @default(true)
  frequency     String    @default("weekly") // "daily", "weekly", "monthly"
  dayOfWeek     Int       @default(1)        // 0=Sun, 1=Mon, ..., 6=Sat (for weekly)
  hourUtc       Int       @default(6)        // Hour in UTC (0-23)
  lastSyncAt    DateTime?
  lastSyncStatus String?  // "completed", "failed"
  updatedBy     String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

// Detailed reconciliation activity log — Gradient MSP style.
// Tracks every count change, approval, dismissal, and PSA write-back.
model BillingActivityEntry {
  id                String   @id @default(cuid())
  companyId         String
  companyName       String
  agreementName     String?  // CW agreement name
  productName       String   // PSA product / service name
  vendorToolId      String   // ninjaone, sentinelone, cove
  vendorProductName String?  // Human-readable vendor product name
  psaQty            Float    // CW billed quantity at the time
  vendorQty         Float    // Vendor-reported count at the time
  change            Float    // vendorQty - psaQty (positive = underbilled)
  effectiveDate     DateTime? // When the change takes effect in CW
  action            String   // "detected" | "approved" | "dismissed" | "synced_to_psa" | "auto_approved"
  result            String   @default("pending") // "pending" | "success" | "failed" | "no_action"
  resultNote        String?  // Extra detail (e.g. "PSA qty updated from 5 to 8")
  actorId           String?  // userId who performed the action (null = system/auto)
  actorName         String?  // Denormalized for display
  snapshotId        String?  // Link back to reconciliation snapshot
  reconciliationItemId String? // Link back to the specific item
  createdAt         DateTime @default(now())

  @@index([companyId])
  @@index([createdAt])
  @@index([action])
  @@index([vendorToolId])
}

// Org-wide billing reconciliation settings (singleton — one row, upserted on save).
model BillingSettings {
  id                   String   @id @default(cuid())
  defaultEffectiveDate String   @default("today") // "today" | "cycle_start" | "custom"
  customEffectiveDay   Int? // Day of month (1-28) when "custom"
  defaultContractView  String   @default("active_only") // "all" | "active_only" | "discrepancies_only"
  autoApproveMatches   Boolean  @default(true) // Auto-approve items with 0 discrepancy
  showCostData         Boolean  @default(true) // Show cost/profit columns to managers
  updatedBy            String?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
}

// Maps a Company to its org/site ID in each non-PSA tool.
// ConnectWise mapping is inherent via Company.psaSourceId — not stored here.
model CompanyIntegrationMapping {
  id           String    @id @default(cuid())
  companyId    String
  company      Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  toolId       String    // "ninjaone", "sentinelone", "itglue", etc.
  externalId   String    // org/site ID in the external tool
  externalName String    // org name at match time (detect drift)
  matchMethod  String    @default("manual") // "auto" | "manual" | "exact"
  matchScore   Float?    // similarity score when auto-matched (0.0–1.0)
  verifiedBy   String?   // userId of admin who verified/confirmed
  verifiedAt   DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@unique([toolId, externalId]) // one Company per external org per tool
  @@unique([companyId, toolId])  // one mapping per Company per tool
  @@index([companyId])
  @@index([toolId])
}

// Maps app User to their member/tech ID in external tools (initially CW members).
// Needed for: ticket assignment, time entries, "my tickets" filtering.
model UserIntegrationMapping {
  id            String   @id @default(cuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  toolId        String   // "connectwise"
  externalId    String   // e.g., ConnectWise member ID
  externalName  String?  // display name from the tool
  externalEmail String?  // email from the tool (used for auto-matching)
  matchMethod   String   @default("manual") // "auto_email" | "manual"
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([toolId, externalId])
  @@unique([userId, toolId])
  @@index([userId])
}

// Per-customer backup notes (stored locally, not in Cove).
model BackupCustomerNote {
  id            String   @id @default(cuid())
  covePartnerId String   @unique // Cove partner/customer ID
  note          String
  updatedBy     String?
  updatedAt     DateTime @updatedAt
  createdAt     DateTime @default(now())

  @@index([covePartnerId])
}

// ─── 3CX PBX Management ─────────────────────────────────────────

// One record per customer PBX — 3CX is multi-instance (one PBX per client).
// Credentials stored encrypted (AES-256-GCM). PBXs map to Companies.
model ThreecxInstance {
  id                   String    @id @default(cuid())
  name                 String    // friendly name (e.g., "JB Dawson PBX")
  fqdn                 String    @unique // e.g., "jbdawson.my3cx.us"
  extensionNumber      String    // system owner extension for API auth
  encryptedPassword    String    // AES-256-GCM encrypted web client password
  companyId            String?
  company              Company?  @relation(fields: [companyId], references: [id], onDelete: SetNull)
  companyName          String?   // free-text company name (used when not linked to a CW company)
  status               String    @default("unknown") // online | offline | degraded | unknown
  version              String?
  os                   String?
  isActive             Boolean   @default(true)
  lastHealthCheck      DateTime?
  lastSeenAt           DateTime?

  // License info (all from polling — not manually set)
  productCode          String?   // e.g. "3CXPSPROFENTSPLA" — parsed for license type display
  maxSimCalls          Int?      // from SystemStatus.MaxSimCalls
  expirationDate       DateTime? // license expiration
  maintenanceExpiresAt DateTime? // maintenance expiration
  updateAvailable      Boolean?  // from GetUpdatesStats (future)
  latestVersion        String?   // newest available version (future)

  // Cached status fields (updated by polling, avoids live queries for dashboard)
  callsActive          Int?
  extensionsRegistered Int?      // phones currently registered
  extensionsTotal      Int?      // total configured extensions
  userExtensions       Int?      // user extensions configured (e.g. 2)
  maxUserExtensions    Int?      // license limit for user extensions (e.g. 15)
  trunksRegistered     Int?
  trunksTotal          Int?
  cpuUsage             Float?
  diskUsagePercent     Int?
  hasFailedServices    Boolean?

  // SSO Deployment — SSH credentials for on-prem relay agent file deployment
  localIp              String?   // LAN IP of PBX (e.g., "10.0.1.50")
  sshUsername          String?   // SSH user (typically "root")
  encryptedSshPassword String?   // AES-256-GCM encrypted SSH password
  ssoDeployed          Boolean   @default(false) // SSO files currently deployed
  ssoDeployedAt        DateTime? // last successful SSO deployment
  ssoDeployStatus      String?   // pending | deploying | deployed | failed

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([companyId])
  @@index([status])
  @@index([isActive])
}

// ─── On-Prem Relay Agent ────────────────────────────────────────

// Registered relay agent running in the customer's datacenter.
// Authenticates via API key (bcrypt-hashed). Polls for tasks and
// executes them on the local network (SSH deployments, etc.).
model OnPremAgent {
  id            String    @id @default(cuid())
  name          String    // friendly name, e.g., "HQ Relay Agent"
  apiKeyHash    String    // bcrypt hash of the agent's API key
  apiKeyPrefix  String    // first 8 chars for identification (e.g., "rcc_ag_1")
  isActive      Boolean   @default(true)
  lastHeartbeat DateTime? // updated every poll cycle
  lastIp        String?   // IP from last heartbeat
  version       String?   // agent software version (self-reported)
  createdBy     String?   // userId of admin who registered
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  tasks AgentTask[]

  @@index([apiKeyPrefix])
  @@index([isActive])
}

// Task queue for the on-prem relay agent. Each row = one job.
// Lifecycle: pending → claimed → completed | failed
model AgentTask {
  id               String    @id @default(cuid())
  agentId          String?   // null when pending; set when agent claims
  agent            OnPremAgent? @relation(fields: [agentId], references: [id], onDelete: SetNull)
  type             String    // "deploy_sso" (extensible for future task types)
  status           String    @default("pending") // pending | claimed | completed | failed
  targetInstanceId String    // ThreecxInstance.id

  payload      Json?     // populated at claim time (SSH creds, file contents, paths)
  result       Json?     // { success: true } or { error: "..." }
  errorMessage String?   // human-readable error for display

  attempts     Int       @default(0)
  maxAttempts  Int       @default(3)
  lastAttemptAt DateTime?

  createdBy   String?   // userId of admin who triggered
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  completedAt DateTime?

  @@index([status])
  @@index([agentId])
  @@index([targetInstanceId])
  @@index([status, createdAt])
}

// ─── Quick Links ────────────────────────────────────────────────

// A named link group assigned to roles/users (e.g., "All Techs", "Security Team")
model QuickLinkGroup {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  sortOrder   Int      @default(0)
  createdBy   String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  items       QuickLinkItem[]
  assignments QuickLinkAssignment[]

  @@index([sortOrder])
}

// A folder or link within a group. Supports 1 level of folder nesting.
// type = "FOLDER" → url is null, can have children
// type = "LINK"   → url is set, no children
model QuickLinkItem {
  id        String          @id @default(cuid())
  groupId   String
  group     QuickLinkGroup  @relation(fields: [groupId], references: [id], onDelete: Cascade)
  parentId  String?
  parent    QuickLinkItem?  @relation("FolderChildren", fields: [parentId], references: [id], onDelete: Cascade)
  children  QuickLinkItem[] @relation("FolderChildren")
  type      String          // "FOLDER" or "LINK"
  title     String
  url       String?
  sortOrder Int             @default(0)
  createdBy String?
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt

  @@index([groupId])
  @@index([parentId])
  @@index([groupId, parentId, sortOrder])
}

// Assigns a group's visibility to a Role or a specific User.
// Either role or userId is set (not both) — validated at the app level.
model QuickLinkAssignment {
  id         String          @id @default(cuid())
  groupId    String
  group      QuickLinkGroup  @relation(fields: [groupId], references: [id], onDelete: Cascade)
  role       Role?
  userId     String?
  user       User?           @relation(fields: [userId], references: [id], onDelete: Cascade)
  assignedBy String?
  assignedAt DateTime        @default(now())

  @@unique([groupId, role])
  @@unique([groupId, userId])
  @@index([role])
  @@index([userId])
}

// ─── AI Provider & Cost Management ──────────────────────────────

enum AiProviderType {
  AZURE_OPENAI
  OPENAI
  CUSTOM // OpenAI-compatible endpoint (Ollama, vLLM, LM Studio, etc.)
}

// AI provider connection — singleton-ish (one active provider at a time)
model AiProviderConfig {
  id             String         @id @default(cuid())
  providerType   AiProviderType
  endpointUrl    String         // e.g., https://myresource.openai.azure.com/ or http://10.0.1.50:11434/v1
  apiKey         String         // Encrypted (AES-256-GCM via crypto.ts)
  apiVersion     String?        // Azure OpenAI API version (e.g., "2024-12-01-preview")
  complexModel   String         @default("gpt-4o")
  simpleModel    String         @default("gpt-4o-mini")
  embeddingModel String         @default("text-embedding-3-small")
  isActive       Boolean        @default(true)
  updatedBy      String?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
}

// Per-function model tier assignment (admin-configurable)
model AiModelConfig {
  id           String   @id @default(cuid())
  functionName String   @unique // "create_ticket", "search_knowledge", etc.
  modelTier    String   // "complex" | "simple" — resolves to provider's complexModel/simpleModel
  customModel  String?  // Optional override: specific model name (bypasses tier)
  updatedBy    String?
  updatedAt    DateTime @updatedAt

  @@index([functionName])
}

// Per-user or per-role budget and rate limit configuration
model AiBudgetConfig {
  id                String   @id @default(cuid())
  entityType        String   // "user" | "role"
  entityId          String   // userId or role name (e.g., "ADMIN", "USER")
  dailyTokenLimit   Int?     // null = unlimited
  monthlyTokenLimit Int?     // null = unlimited
  rateLimitPerHour  Int?     // max AI requests/hour, null = unlimited
  maxConcurrent     Int      @default(1)
  isActive          Boolean  @default(true)
  updatedBy         String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([entityType, entityId])
  @@index([entityType])
}

// Per-request AI usage tracking (append-only)
model AiUsageLog {
  id           String   @id @default(cuid())
  userId       String
  functionName String
  model        String   // Actual model name used
  provider     String   // "azure_openai" | "openai" | "custom"
  inputTokens  Int
  outputTokens Int
  totalTokens  Int
  cached       Boolean  @default(false)
  latencyMs    Int
  success      Boolean  @default(true)
  error        String?
  createdAt    DateTime @default(now())

  @@index([userId])
  @@index([functionName])
  @@index([createdAt])
  @@index([userId, createdAt])
}
