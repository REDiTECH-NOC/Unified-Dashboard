generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  MANAGER
  USER
  CLIENT
}

enum AuthMethod {
  ENTRA
  LOCAL
}

enum MonitorType {
  HTTP
  TCP
  PING
  DNS
  REDIS
  MYSQL
  POSTGRESQL
  SQLSERVER
  MONGODB
  DOCKER
}

enum MonitorStatus {
  UP
  DOWN
  PENDING
  UNKNOWN
}

enum AuditCategory {
  AUTH
  USER
  SECURITY
  INTEGRATION
  NOTIFICATION
  SYSTEM
  API
  DATA
}

model User {
  id            String     @id @default(cuid())
  email         String     @unique
  name          String?
  avatar        String?
  entraId       String?    @unique
  role          Role       @default(USER)
  authMethod    AuthMethod @default(ENTRA)

  // Local auth fields (glass-break admin, future local users/clients)
  passwordHash  String?
  totpSecret    String?
  totpEnabled   Boolean    @default(false)
  mustSetupTotp Boolean    @default(false)

  // Future: invite flow for local users / clients
  inviteToken   String?    @unique
  inviteExpiry  DateTime?

  lastLoginAt   DateTime?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  auditEvents         AuditEvent[]
  preferences         UserPreference[]
  featureFlags        UserFeatureFlag[]
  permissions         UserPermission[]
  permissionRoles     UserPermissionRole[]
  integrationMappings UserIntegrationMapping[]
  quickLinkAssignments QuickLinkAssignment[]

  @@index([role])
  @@index([authMethod])
}

model AuditEvent {
  id        String        @id @default(cuid())
  action    String
  category  AuditCategory @default(SYSTEM)
  actorId   String?
  actor     User?         @relation(fields: [actorId], references: [id])
  resource  String?
  detail    Json?
  ip        String?
  userAgent String?
  outcome   String        @default("success")
  createdAt DateTime      @default(now())

  @@index([action])
  @@index([category])
  @@index([actorId])
  @@index([createdAt])
  @@index([resource])
  @@index([outcome])
  @@index([category, createdAt])
  @@index([actorId, createdAt])
}

model UserPreference {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  key       String
  value     Json
  updatedAt DateTime @updatedAt

  @@unique([userId, key])
}

model UserFeatureFlag {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  flag      String
  enabled   Boolean  @default(false)
  value     Json?
  updatedBy String?
  updatedAt DateTime @updatedAt

  @@unique([userId, flag])
}

model UserPermission {
  id         String   @id @default(cuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  permission String   // e.g. "audit.view", "users.manage", "kb.write"
  granted    Boolean  @default(true) // true = explicitly granted, false = explicitly revoked
  grantedBy  String?  // userId of admin who set this
  grantedAt  DateTime @default(now())

  @@unique([userId, permission])
  @@index([userId])
}

// Named permission groups that admins create and assign to users
// e.g. "Senior Tech" grants ai.kb.write + audit.view + reports.view
// Users can have multiple roles — most permissive wins
model PermissionRole {
  id          String   @id @default(cuid())
  name        String   @unique  // e.g. "Senior Tech", "Help Desk", "Security Analyst"
  description String?
  permissions String[] // array of permission keys: ["ai.kb.write", "audit.view"]
  createdBy   String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  users UserPermissionRole[]
}

// Join table: which users have which permission roles
model UserPermissionRole {
  id               String         @id @default(cuid())
  userId           String
  user             User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  permissionRoleId String
  permissionRole   PermissionRole @relation(fields: [permissionRoleId], references: [id], onDelete: Cascade)
  assignedBy       String?
  assignedAt       DateTime       @default(now())

  @@unique([userId, permissionRoleId])
  @@index([userId])
}

model IntegrationConfig {
  id              String    @id @default(cuid())
  toolId          String    @unique
  displayName     String
  category        String
  credentialRef   String?
  status          String    @default("unconfigured")
  lastHealthCheck DateTime?
  lastSync        DateTime?
  config          Json?
  updatedBy       String?
  updatedAt       DateTime  @updatedAt
}

model NotificationConfig {
  id              String   @id @default(cuid())
  type            String   @unique  // e.g. "alert_critical", "report_daily"
  displayName     String
  description     String?
  emailEnabled    Boolean  @default(false)
  emailSender     String?  // e.g. "alerts@cloudjohnson.com"
  emailRecipients String[] // array of email addresses
  teamsEnabled    Boolean  @default(false)
  teamsWebhookUrl String?
  smsEnabled      Boolean  @default(false)
  smsRecipients   String[] // array of phone numbers
  updatedBy       String?
  updatedAt       DateTime @updatedAt
}

// ─── In-App Notifications ──────────────────────────────────────

model InAppNotification {
  id         String   @id @default(cuid())
  userId     String
  type       String   // "ticket_assigned", "ticket_reply", "ticket_status_changed", "ticket_created"
  title      String
  body       String?
  read       Boolean  @default(false)
  linkUrl    String?
  sourceType String?  // "connectwise_ticket"
  sourceId   String?
  metadata   Json?
  expiresAt  DateTime?
  createdAt  DateTime @default(now())

  @@index([userId, read, createdAt(sort: Desc)])
  @@index([userId, createdAt(sort: Desc)])
  @@index([expiresAt])
}

// ─── Notification Delivery Channels (admin-managed) ─────────────

model NotificationChannel {
  id        String   @id @default(cuid())
  type      String   // "push" | "email" | "teams" | "sms"
  name      String   // "Browser Push", "Email", "NOC Alerts Channel"
  config    Json     @default("{}")
  isBuiltIn Boolean  @default(false) // push + email are built-in, can't be deleted
  enabled   Boolean  @default(true)
  createdBy String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([type, name])
}

// ─── User Notification Preferences (per-source, per-user) ──────

model UserNotificationPref {
  id         String   @id @default(cuid())
  userId     String
  source     String   // "sentinelone", "blackpoint", "ninjaone", "uptime", "cove"
  enabled    Boolean  @default(true)
  severities String[] // multi-select: ["critical", "high"]
  channels   String[] // delivery channels: ["push", "email", "teams:<channel-id>"]
  updatedAt  DateTime @updatedAt

  @@unique([userId, source])
  @@index([userId])
}

// ─── Uptime Monitoring ──────────────────────────────────────────

model Monitor {
  id              String        @id @default(cuid())
  name            String
  type            MonitorType
  active          Boolean       @default(true)

  // Organization assignment (optional — link to a client company)
  companyId       String?
  company         Company?      @relation(fields: [companyId], references: [id], onDelete: SetNull)

  // Scheduling
  intervalSeconds Int           @default(60)
  retrySeconds    Int           @default(60)
  maxRetries      Int           @default(3)
  timeoutMs       Int           @default(10000)

  // Current state (denormalized for fast list queries)
  status          MonitorStatus @default(PENDING)
  lastCheckedAt   DateTime?
  lastStatusChange DateTime?

  // Per-type config (JSONB — discriminated by type)
  config          Json          @default("{}")

  description     String?
  sslExpiryDays   Int           @default(30)

  createdBy       String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  heartbeats      Heartbeat[]
  tags            MonitorTagAssignment[]

  @@index([active])
  @@index([status])
  @@index([type])
  @@index([companyId])
}

model Heartbeat {
  id          String        @id @default(cuid())
  monitorId   String
  monitor     Monitor       @relation(fields: [monitorId], references: [id], onDelete: Cascade)
  status      MonitorStatus
  latencyMs   Int?
  message     String?

  // SSL/TLS info (populated on HTTPS checks)
  tlsInfo     Json?         // { issuer, subject, validFrom, validTo, daysUntilExpiry, fingerprint }

  // DNS result
  dnsResult   Json?         // { resolvedAddresses: string[], recordType: string }

  timestamp   DateTime      @default(now())

  @@index([monitorId, timestamp(sort: Desc)])
  @@index([timestamp])
  @@index([monitorId, status])
}

model MonitorTag {
  id        String   @id @default(cuid())
  name      String   @unique
  color     String   @default("#ef4444") // hex color for badge display
  createdBy String?
  createdAt DateTime @default(now())

  monitors  MonitorTagAssignment[]
}

model MonitorTagAssignment {
  id        String     @id @default(cuid())
  monitorId String
  monitor   Monitor    @relation(fields: [monitorId], references: [id], onDelete: Cascade)
  tagId     String
  tag       MonitorTag @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([monitorId, tagId])
  @@index([monitorId])
  @@index([tagId])
}

// ─── Company Management ─────────────────────────────────────────

// Local company record — PSA (ConnectWise) is the source of truth.
// All other tools map to these records via CompanyIntegrationMapping.
model Company {
  id             String    @id @default(cuid())
  name           String
  psaSourceId    String    @unique // ConnectWise company ID — authoritative link
  identifier     String?           // CW short code (e.g., "JBDAW")
  status         String    @default("Active")
  type           String?           // CW company type name (e.g. "Client", "Prospect")
  phone          String?
  website        String?
  addressLine1   String?
  addressLine2   String?
  city           String?
  state          String?
  zip            String?
  country        String?
  lastSyncedAt   DateTime?
  syncEnabled    Boolean   @default(true)
  syncSource     String    @default("manual") // "auto" | "manual"
  unmatchedSince DateTime?                    // when auto-sync detected no longer matches (null = matches)

  // ── In-App Custom Fields (admin-editable, NOT synced from CW) ──
  afterHoursAlertProcedure String?  // Free text: what to do for after-hours alerts
  notes                    String?  // General admin notes about this company

  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  integrationMappings CompanyIntegrationMapping[]
  threecxInstances    ThreecxInstance[]
  monitors            Monitor[]
  contacts            CompanyContact[]
  sites               CompanySite[]
  configurations      CompanyConfiguration[]
  agreements          CompanyAgreement[]

  @@index([name])
  @@index([status])
  @@index([syncSource])
}

// Contacts synced from ConnectWise — needed for 3CX caller intelligence, ticket creation
model CompanyContact {
  id                 String    @id @default(cuid())
  companyId          String
  company            Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  psaSourceId        String    @unique // CW contact ID
  firstName          String
  lastName           String
  title              String?
  email              String?
  phone              String?
  mobilePhone        String?
  defaultFlag        Boolean   @default(false)
  inactiveFlag       Boolean   @default(false)
  communicationItems Json?     // full CW communicationItems array for extended lookups
  lastSyncedAt       DateTime?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  @@index([companyId])
  @@index([email])
  @@index([phone])
  @@index([mobilePhone])
}

// Sites/locations synced from ConnectWise — company office addresses
model CompanySite {
  id           String    @id @default(cuid())
  companyId    String
  company      Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  psaSourceId  String    @unique // CW site ID
  name         String
  addressLine1 String?
  city         String?
  state        String?
  zip          String?
  country      String?
  phone        String?
  primaryFlag  Boolean   @default(false)
  inactiveFlag Boolean   @default(false)
  lastSyncedAt DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([companyId])
}

// Device/asset configurations synced from ConnectWise — needed for contract reconciliation
model CompanyConfiguration {
  id           String    @id @default(cuid())
  companyId    String
  company      Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  psaSourceId  String    @unique // CW configuration ID
  name         String
  type         String?
  status       String?
  serialNumber String?
  modelNumber  String?
  osType       String?
  osInfo       String?
  ipAddress    String?
  macAddress   String?
  lastSyncedAt DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([companyId])
}

// Agreements/contracts synced from ConnectWise — needed for billing reconciliation
model CompanyAgreement {
  id               String    @id @default(cuid())
  companyId        String
  company          Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  psaSourceId      String    @unique // CW agreement ID
  name             String
  type             String?
  startDate        DateTime?
  endDate          DateTime?
  cancelledFlag    Boolean   @default(false)
  noEndingDateFlag Boolean   @default(false)
  billAmount       Float?
  billCycle        String?
  lastSyncedAt     DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  @@index([companyId])
}

// Maps a Company to its org/site ID in each non-PSA tool.
// ConnectWise mapping is inherent via Company.psaSourceId — not stored here.
model CompanyIntegrationMapping {
  id           String    @id @default(cuid())
  companyId    String
  company      Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  toolId       String    // "ninjaone", "sentinelone", "itglue", etc.
  externalId   String    // org/site ID in the external tool
  externalName String    // org name at match time (detect drift)
  matchMethod  String    @default("manual") // "auto" | "manual" | "exact"
  matchScore   Float?    // similarity score when auto-matched (0.0–1.0)
  verifiedBy   String?   // userId of admin who verified/confirmed
  verifiedAt   DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@unique([toolId, externalId]) // one Company per external org per tool
  @@unique([companyId, toolId])  // one mapping per Company per tool
  @@index([companyId])
  @@index([toolId])
}

// Maps app User to their member/tech ID in external tools (initially CW members).
// Needed for: ticket assignment, time entries, "my tickets" filtering.
model UserIntegrationMapping {
  id            String   @id @default(cuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  toolId        String   // "connectwise"
  externalId    String   // e.g., ConnectWise member ID
  externalName  String?  // display name from the tool
  externalEmail String?  // email from the tool (used for auto-matching)
  matchMethod   String   @default("manual") // "auto_email" | "manual"
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([toolId, externalId])
  @@unique([userId, toolId])
  @@index([userId])
}

// Per-customer backup notes (stored locally, not in Cove).
model BackupCustomerNote {
  id            String   @id @default(cuid())
  covePartnerId String   @unique // Cove partner/customer ID
  note          String
  updatedBy     String?
  updatedAt     DateTime @updatedAt
  createdAt     DateTime @default(now())

  @@index([covePartnerId])
}

// ─── 3CX PBX Management ─────────────────────────────────────────

// One record per customer PBX — 3CX is multi-instance (one PBX per client).
// Credentials stored encrypted (AES-256-GCM). PBXs map to Companies.
model ThreecxInstance {
  id                   String    @id @default(cuid())
  name                 String    // friendly name (e.g., "JB Dawson PBX")
  fqdn                 String    @unique // e.g., "jbdawson.my3cx.us"
  extensionNumber      String    // system owner extension for API auth
  encryptedPassword    String    // AES-256-GCM encrypted web client password
  companyId            String?
  company              Company?  @relation(fields: [companyId], references: [id], onDelete: SetNull)
  status               String    @default("unknown") // online | offline | degraded | unknown
  version              String?
  os                   String?
  isActive             Boolean   @default(true)
  lastHealthCheck      DateTime?
  lastSeenAt           DateTime?

  // Cached status fields (updated by polling, avoids live queries for dashboard)
  callsActive          Int?
  extensionsRegistered Int?
  extensionsTotal      Int?
  trunksRegistered     Int?
  trunksTotal          Int?
  cpuUsage             Float?
  diskUsagePercent     Int?
  hasFailedServices    Boolean?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([companyId])
  @@index([status])
  @@index([isActive])
}

// ─── Quick Links ────────────────────────────────────────────────

// A named link group assigned to roles/users (e.g., "All Techs", "Security Team")
model QuickLinkGroup {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  sortOrder   Int      @default(0)
  createdBy   String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  items       QuickLinkItem[]
  assignments QuickLinkAssignment[]

  @@index([sortOrder])
}

// A folder or link within a group. Supports 1 level of folder nesting.
// type = "FOLDER" → url is null, can have children
// type = "LINK"   → url is set, no children
model QuickLinkItem {
  id        String          @id @default(cuid())
  groupId   String
  group     QuickLinkGroup  @relation(fields: [groupId], references: [id], onDelete: Cascade)
  parentId  String?
  parent    QuickLinkItem?  @relation("FolderChildren", fields: [parentId], references: [id], onDelete: Cascade)
  children  QuickLinkItem[] @relation("FolderChildren")
  type      String          // "FOLDER" or "LINK"
  title     String
  url       String?
  sortOrder Int             @default(0)
  createdBy String?
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt

  @@index([groupId])
  @@index([parentId])
  @@index([groupId, parentId, sortOrder])
}

// Assigns a group's visibility to a Role or a specific User.
// Either role or userId is set (not both) — validated at the app level.
model QuickLinkAssignment {
  id         String          @id @default(cuid())
  groupId    String
  group      QuickLinkGroup  @relation(fields: [groupId], references: [id], onDelete: Cascade)
  role       Role?
  userId     String?
  user       User?           @relation(fields: [userId], references: [id], onDelete: Cascade)
  assignedBy String?
  assignedAt DateTime        @default(now())

  @@unique([groupId, role])
  @@unique([groupId, userId])
  @@index([role])
  @@index([userId])
}

// ─── AI Provider & Cost Management ──────────────────────────────

enum AiProviderType {
  AZURE_OPENAI
  OPENAI
  CUSTOM // OpenAI-compatible endpoint (Ollama, vLLM, LM Studio, etc.)
}

// AI provider connection — singleton-ish (one active provider at a time)
model AiProviderConfig {
  id             String         @id @default(cuid())
  providerType   AiProviderType
  endpointUrl    String         // e.g., https://myresource.openai.azure.com/ or http://10.0.1.50:11434/v1
  apiKey         String         // Encrypted (AES-256-GCM via crypto.ts)
  apiVersion     String?        // Azure OpenAI API version (e.g., "2024-12-01-preview")
  complexModel   String         @default("gpt-4o")
  simpleModel    String         @default("gpt-4o-mini")
  embeddingModel String         @default("text-embedding-3-small")
  isActive       Boolean        @default(true)
  updatedBy      String?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
}

// Per-function model tier assignment (admin-configurable)
model AiModelConfig {
  id           String   @id @default(cuid())
  functionName String   @unique // "create_ticket", "search_knowledge", etc.
  modelTier    String   // "complex" | "simple" — resolves to provider's complexModel/simpleModel
  customModel  String?  // Optional override: specific model name (bypasses tier)
  updatedBy    String?
  updatedAt    DateTime @updatedAt

  @@index([functionName])
}

// Per-user or per-role budget and rate limit configuration
model AiBudgetConfig {
  id                String   @id @default(cuid())
  entityType        String   // "user" | "role"
  entityId          String   // userId or role name (e.g., "ADMIN", "USER")
  dailyTokenLimit   Int?     // null = unlimited
  monthlyTokenLimit Int?     // null = unlimited
  rateLimitPerHour  Int?     // max AI requests/hour, null = unlimited
  maxConcurrent     Int      @default(1)
  isActive          Boolean  @default(true)
  updatedBy         String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([entityType, entityId])
  @@index([entityType])
}

// Per-request AI usage tracking (append-only)
model AiUsageLog {
  id           String   @id @default(cuid())
  userId       String
  functionName String
  model        String   // Actual model name used
  provider     String   // "azure_openai" | "openai" | "custom"
  inputTokens  Int
  outputTokens Int
  totalTokens  Int
  cached       Boolean  @default(false)
  latencyMs    Int
  success      Boolean  @default(true)
  error        String?
  createdAt    DateTime @default(now())

  @@index([userId])
  @@index([functionName])
  @@index([createdAt])
  @@index([userId, createdAt])
}
